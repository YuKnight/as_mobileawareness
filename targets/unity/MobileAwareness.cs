using UnityEngine;
using System.Collections;
using System.Runtime.InteropServices;
using System;
using System.Text;

// Copyright 2019 J Forristal LLC
  // Copyright 2016 Addition Security Inc.
  //
  // Licensed under the Apache License, Version 2.0 (the "License");
  // you may not use this file except in compliance with the License.
  // You may obtain a copy of the License at
  //
  //    http://www.apache.org/licenses/LICENSE-2.0
  //
  // Unless required by applicable law or agreed to in writing, software
  // distributed under the License is distributed on an "AS IS" BASIS,
  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  // See the License for the specific language governing permissions and
  // limitations under the License.

public class MobileAwareness {

    //
    // Return values of the various SDK APIs
    //
    public const int AS_INIT_ERR_MORE_THAN_ONCE = 1;
    public const int AS_INIT_SUCCESS = 0;
    public const int AS_INIT_ERR_GENERAL = -1;
    public const int AS_INIT_ERR_LICENSE = -2;
    public const int AS_INIT_ERR_INTEGRITY = -3;
    public const int AS_INIT_ERR_ARMONX86 = -4;

    public const int AS_SUCCESS = 0;
    public const int AS_ERR_GENERAL = -1;


    //
    // Initialization result callback; check for any of the AS_INIT_* return codes and respond accordingly
    //
    private static void inititializeResult(int result)
    {
        if( result != AS_INIT_SUCCESS)
        {
            // SOMETHING BAD HAPPENED!  The library couldn't initialize properly
            //
            // Include failure handling here

            // ... Your logic ...
            Debug.Log("ERROR INITIALIZING MOBILEAWARENESS SDK");
        }
    }


    //
    // Event callback -- customize this to respond to the various security events generated by the SDK
    //
    [AOT.MonoPInvokeCallback(typeof(EventCallbackFunc))]
    private static void eventCallback(int id, int subid, IntPtr data1Ptr, UInt32 data1_len, IntPtr data2Ptr, UInt32 data2_len)
    {
        // The callback must not propogate any exceptions back to the SDK, so wrap everything with a try/catch block
        try
        {

            //
            // Enable this code if you wish to access/review the data parameters in your response logic:
#if false
            byte[] data1 = null;
            if (data1Ptr != IntPtr.Zero)
            {
                // NOTE: data1_len could be zero
                data1 = new byte[data1_len];
                if (data1_len > 0)
                    Marshal.Copy(data1Ptr, data1, 0, (int)(data1_len & 0xfffff));
            }

            byte[] data2 = null;
            if (data2Ptr != IntPtr.Zero)
            {
                // NOTE: data2_len could be zero
                data2 = new byte[data2_len];
                if (data2_len > 0)
                    Marshal.Copy(data2Ptr, data2, 0, (int)(data2_len & 0xfffff));
            }
#endif

            // FOR DEBUGGING ONLY:
            Debug.Log("Event Callback: " + id.ToString() + "/" + subid.ToString());


            //
            // Malware on the device
            //
            if( id == 150       // 150: Known Malware Artifact Detected
                || id == 152    // 152: Known Malware Signer Present
                )
            {
                // ... Your response ...
                Debug.Log("SECURITY: MALWARE");
            }

            //
            // Application vulnerabilities
            //
            if( id == 252       // 252: Open Application Local Attack Vector
                || id == 253    // 253: Open Application Remote Attack Vector
                )
            {
                // ... Your response ...
                Debug.Log("SECURITY: APP VULNERABILITY");
            }

            if( id == 300        // 300: Synthetic System (Emulator/Simulator)
                )
            {
                // ... Your response ...
                Debug.Log("SECURITY: EMULATOR");
            }

            if( id == 302       // 302: Non-Production System
                || id == 317    // 317: System Unsigned (Android)
                )
            {             
                // WARNING: unfortunately there are Android vendors that ship devices that don't
                // meet Google's requirements for production, e.g. debug builds, signed with test
                // keys, etc.  These are effectively development builds that got sent to market,
                // and are indistinguishable from development builds that a hacker may make to
                // try to compromise an app.  Most users don't know they purchased an at-risk
                // development grade device/firmware build, and are in no position to really
                // remedy it except for buy a new device.  Therefore, you should consider using
                // thes category of indicators passively if you do not want to snag a few
                // innocent users who unfortunately bought sketchy devices.

                // ... Your response ...
                Debug.Log("SECURITY: NONPRODUCTION DEVICE");
            }

            if( id == 305       // 305: Privilege Providing Application (SU, etc.)
                || id == 314    // 314: System Rooted/Jailbroken
                )
            {
                // ... Your response ...
                Debug.Log("SECURITY: ROOTED/JAILBROKEN");
            }

            if( id == 307       // 307: Hacking Tool Installed
                || id == 308    // 308: Security Subversion Tool Installed (rooting/jailbreak exploit)
                || id == 315    // 315: Security Hiding Tool Installed (trying to hide root/jailbreak)
                )
            {
                // ... Your response ...
                Debug.Log("SECURITY: SECURITY TOOL/EXPLOIT");
            }

            if( id == 309       // 309: Application Tampering Tool Installed
                || id == 310    // 310: Game Cheat Tool Installed
                || id == 311    // 311: In-App Purchasing Fraud Tool Installed
                )
            {
                // ... Your response ...
                Debug.Log("SECURITY: CHEAT/FRAUD TOOL");
            }

            if( id == 312       // 312: Test/Automation Tool Installed
                || id == 318    // 318: ADBD Running (Android Developer Bridge)
                )
            {
                // ... Your response ...
                Debug.Log("SECURITY: DEVELOPMENT/TEST ITEMS");
            }

            if( id == 313       // 313: Security Expectation Failure (sandbox security is broken)
                || id == 411    // 411: Security Operation Failure (system security call failed)
                )
            {
                // ... Your response ...
                Debug.Log("SECURITY: RUNTIME OPERATION VIOLATION");
            }

            if( id == 400       // 400: Debugger/Instrumentation Detected
                )
            {
                // ... Your response ...
                Debug.Log("SECURITY: DEBUGGER DETECTED");
            }

            if( id == 401       // 401: Application Tampering Detected
                || id == 403    // 403: Application Encryption Disabled (IOS: app-store app got cracked)
                || id == 406    // 406: Stealth Callback Failure (Advanced MobileAwareness feature)
                || id == 410    // 410: Provisiong Corrupted (unable to read embedded provisioning profile)
                || id == 416    // 416: Heartbeat failure (re: heartbeat() API call)
                )
            {
                // ... Your response ...
                Debug.Log("SECURITY: RUNTIME APP VIOLATION");
            }

            if( id == 402       // 402: Application Unencrypted (IOS non-app-store install)
                || id == 409    // 409: Provisioning Missing (sideloaded or not from known app store)
                || id == 413    // 412: Application is Developer Signed
                || id == 414    // 414: Debug Build (app is a debug/developer build)
                )
            {
                // ... Your response ...
                // NOTE: these are typically seen in development/pre-production installs, but shouldn't
                // occur on production installs going through app stores
                Debug.Log("SECURITY: VIOLATION IF NOT DEVELOPMENT BUILD");
            }

            if( id == 500       // 500: SSL Pin Violation (network MitM attacker detected)
                )
            {
                // ... Your response ...
                Debug.Log("SECURITY: NETWORK ATTACKER");
            }
            

            if( id == 415 )     // 415: Provisioning Provider
            {
                // This message indicates provisioning info.
                // IOS: the information comes from the embedded provisioning profile
                // Android: it contains the package name of the installer, e.g. com.android.vending for Google Play
                //
                // You can test the values against expectations to see if your application is coming from unauthorized
                // stores or getting distributed via ad-hoc means

                // Android:
                // data1: string of package name of installer; may be NULL if sideloaded

                // ... Your logic ...
            }

            if( id == 408 )     // 408: Provisioning Signer
            {
                // This message includes the SHA1 hash of the provisioning profile signer.
                //
                // You can test the values against expectations to see if your application is redistributed.

                // IOS:
                // data1: SHA1 hash byte array (binary, 20 bytes) of certificate in provisioning profile
                // data2: (optional) text string of the certificate X509 subject

                // ... Your logic ...
            }

            if( id == 404 )     // 404: Application Signer
            {
                // This message includes the SHA1 hash of the application signer.
                //
                // You can test the values against expectations to see if your application is resigned.
                //
                // Android:
                // data1: SHA1 hash byte array (binary, 20 bytes) of certificate used to sign APK
                // data2: (optional) text string of the certificate X509 subject
                //
                // IOS:
                // data1: SHA1 hash byte array (binary, 20 bytes) of certificate used to sign the executable
                //        NOTE: this may reflect an Apple signature, if re-signed for App Store distribution
                // data2: (optional) text string of the certificate X509 subject
 
                // ... Your logic ...
            }

            if( id == 407 )     // 407: Application Measurement
            {
                // This message includes the SHA1 hash of the application bundle.
                //
                // You can test the values against expectations to see if your application has been modified.

                if (subid == 10)
                {
                    // Android: This is SHA1 hash of the APK file
                    // data1: SHA1 hash byte array (binary, 20 bytes) of certificate used to sign APK
                    // data2: string of the file name/path on device

                    // ... Your logic ...

                }

                if( subid == 1 )
                {
                    // IOS: THis is the SHA1 hash of the executable file
                    // data1: SHA1 hash byte array (binary, 20 bytes) of certificate used to sign APK
                    // data2: string of the file name/path on device

                    // ... Your logic ...
                }
            }

        }
        catch 
        {
            // Your choice on how to handle errors, as long as they don't propogate back into the SDK
            // ...
        }
    }





    //////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // No need to edit anything below here (for basic operation)
    //

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void EventCallbackFunc(int id, int subid, IntPtr data1Ptr, UInt32 data1_len, IntPtr data2Ptr, UInt32 data2_len);


    //
    // Main SDK initialization.  Must be called once, and as early as possible (e.g. startup object)
    // Callback must be ready to receive calls.
    //
    private static bool _initialized = false;
    public static void initialize()
    {
        if (_initialized)
        {
            inititializeResult(AS_INIT_ERR_MORE_THAN_ONCE);
            return;
        }

#if UNITY_IOS || UNITY_ANDROID
        // Load the as.conf configuration & license file from resources
        TextAsset ta = Resources.Load("asconf", typeof(TextAsset)) as TextAsset;
        byte[] asconf = ta.bytes;

        // Load the as.def definitions file from resources
#if UNITY_IOS
        ta = Resources.Load("asdef_i", typeof(TextAsset)) as TextAsset;
#else
        ta = Resources.Load("asdef_a", typeof(TextAsset)) as TextAsset;
#endif
        byte[] asdef = ta.bytes;

        // result will be sent to the callback
        EventCallbackFunc cb = eventCallback;
        initialize_platform(asconf, asdef, cb);
#else
        // In order to keep existing logic (namely, the callback) preserved, we are going to
        // "fake" the InitializationComplete message here before we return success
        _initialized = true;
        eventCallback(50,0,IntPtr.Zero,0,IntPtr.Zero,0);
        inititializeResult(AS_INIT_SUCCESS);
#endif
    }

    //
    // Associate an authenticated identity with the message stream, for remote correllation
    //
    public static int registerIdentity(string identity)
    {
        if (!_initialized) return AS_ERR_GENERAL;
#if UNITY_IOS || UNITY_ANDROID
        int len = Encoding.UTF8.GetByteCount(identity);
        byte[] buffer = new byte[len + 1]; // +1 for NULL
        Encoding.UTF8.GetBytes(identity, 0, identity.Length, buffer, 0);
        GCHandle pinned = GCHandle.Alloc(buffer, GCHandleType.Pinned);
        int res = AS_Register_Identity(pinned.AddrOfPinnedObject());
        pinned.Free();
        return res;
#else
        return AS_SUCCESS;
#endif
    }

    //
    // Send an arbitrary message to the remote message receiver
    //
    public static int sendMessage(UInt32 id, string data)
    {
        if (!_initialized) return AS_ERR_GENERAL;
#if UNITY_IOS || UNITY_ANDROID
        int len = Encoding.UTF8.GetByteCount(data);
        byte[] buffer = new byte[len + 1]; // +1 for NULL
        Encoding.UTF8.GetBytes(data, 0, data.Length, buffer, 0);
        GCHandle pinned = GCHandle.Alloc(buffer, GCHandleType.Pinned);
        int res = AS_Send_Message(id, pinned.AddrOfPinnedObject());
        pinned.Free();
        return res;
#else
        return AS_SUCCESS;
#endif
    }

    //
    // Let the SDK & remote receiver know of a successful login
    //
    public static void loginSuccess()
    {
        if (!_initialized) return;
#if UNITY_IOS || UNITY_ANDROID
        AS_Login_Status(1);
#endif
    }

    //
    // Let the SDK & remote receiver know of a failed login
    //
    public static void loginFailed()
    {
        if (!_initialized) return;
#if UNITY_IOS || UNITY_ANDROID
        AS_Login_Status(0);
#endif
    }

    //
    // Call upon a change of network conditions, to check the network and
    // flush any pending messages to the remote receiver
    //
    public static void networkReachability()
    {
        if (!_initialized) return;
#if UNITY_IOS || UNITY_ANDROID
        AS_Network_Reachability();
#endif
    }

    //
    // Report the MobileAwareness library version
    //
    public static UInt32 version()
    {
#if UNITY_IOS || UNITY_ANDROID
        return AS_Version();
#else
        return 0;
#endif
    }

    public static long heartbeat(long input)
    {
        if (!_initialized) return -1;
#if UNITY_IOS || UNITY_ANDROID
        return AS_Heartbeat(input);
#else
        // THIS NEEDS TO MATCH YOUR HEARTBEAT VALUE PER YOUR AS.CONF
        return 1234;
#endif
    }


#if UNITY_IOS

    [DllImport("__Internal")]
    private static extern int AS_MobileAwareness_Unity_Init_Bridge( IntPtr config, UInt32 config_len, 
        IntPtr defs, UInt32 defs_len, EventCallbackFunc cb );

    [DllImport("__Internal")]
    private static extern int AS_Register_Identity(IntPtr identity);

    [DllImport("__Internal")]
    private static extern int AS_Send_Message(UInt32 id, IntPtr data);

    [DllImport("__Internal")]
    private static extern long AS_Heartbeat(long input);

    [DllImport("__Internal")]
    private static extern void AS_Login_Status(int status);

    [DllImport("__Internal")]
    private static extern void AS_Network_Reachability();

    [DllImport("__Internal")]
    private static extern UInt32 AS_Version();

    
    private static void initialize_platform(byte[] asconf, byte[] asdef, EventCallbackFunc cb) 
    {
        GCHandle pinned_asconf = GCHandle.Alloc(asconf, GCHandleType.Pinned);
        GCHandle pinned_asdef = GCHandle.Alloc(asdef, GCHandleType.Pinned);

        int res_init = AS_MobileAwareness_Unity_Init_Bridge(pinned_asconf.AddrOfPinnedObject(), (UInt32)asconf.Length, 
                    pinned_asdef.AddrOfPinnedObject(), (UInt32)asdef.Length, cb );

        pinned_asconf.Free();
        pinned_asdef.Free();

        if( res_init == AS_INIT_SUCCESS ) _initialized = true;
        inititializeResult(res_init);
    }


#elif UNITY_ANDROID

    [DllImport("asma")]
    private static extern int AS_Initialize_Unity(IntPtr config, UInt32 config_len, 
        IntPtr defs, UInt32 defs_len, EventCallbackFunc cb);

    [DllImport("asma")]
    private static extern int AS_Register_Identity(IntPtr identity);

    [DllImport("asma")]
    private static extern int AS_Send_Message(UInt32 id, IntPtr data);

    [DllImport("asma")]
    private static extern long AS_Heartbeat(long input);

    [DllImport("asma")]
    private static extern void AS_Login_Status(int status);

    [DllImport("asma")]
    private static extern void AS_Network_Reachability();

    [DllImport("asma")]
    private static extern UInt32 AS_Version();

    

    private static void initialize_platform(byte[] asconf, byte[] asdef, EventCallbackFunc cb) 
    {
        //
        // The initialize must happen on the main UI thread to get the proper JNIEnv
        // reference under the hood.
        //
        AndroidJavaClass unityPlayer = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
        AndroidJavaObject activity = unityPlayer.GetStatic<AndroidJavaObject>("currentActivity");
        activity.Call("runOnUiThread", new AndroidJavaRunnable(() =>
            {
                // We need to load the MobileAwareness SDK class, because it has some
                // static initializing logic that is used for various Java-side detections
                AndroidJavaClass cl = new AndroidJavaClass("com.additionsecurity.MobileAwareness");

                // Pin the asconf byte array and pass it in as a pointer to the Initialize function
                GCHandle pinned_asconf = GCHandle.Alloc(asconf, GCHandleType.Pinned);
                GCHandle pinned_asdef = GCHandle.Alloc(asdef, GCHandleType.Pinned);

                int res_init = AS_Initialize_Unity(pinned_asconf.AddrOfPinnedObject(), (UInt32)asconf.Length, 
                    pinned_asdef.AddrOfPinnedObject(), (UInt32)asdef.Length, cb);

                pinned_asconf.Free();
                pinned_asdef.Free();

                if( res_init == AS_INIT_SUCCESS ) _initialized = true;
                inititializeResult(res_init);
            }));
    }
#endif

}
